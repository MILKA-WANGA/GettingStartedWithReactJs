{"version":3,"names":["Definition","PatternVisitor","OriginalPatternVisitor","Referencer","OriginalReferencer","Scope","ScopeManager","require","getKeys","fallback","visitorKeysMap","getVisitorValues","nodeType","client","FLOW_FLIPPED_ALIAS_KEYS","VISITOR_KEYS","getTypesInfo","flowFlippedAliasKeys","concat","Object","entries","reduce","acc","key","value","includes","propertyTypes","callProperties","type","values","indexers","properties","types","params","argument","elementType","qualification","rest","returnType","typeAnnotation","typeParameters","id","ArrayPattern","node","elements","forEach","visit","ObjectPattern","_client","WeakMap","constructor","options","scopeManager","_classPrivateFieldInitSpec","writable","_classPrivateFieldSet","visitPattern","callback","_checkIdentifierOrVisit","left","processRightHandNodes","visitor","rightHandNodes","visitClass","_visitArray","decorators","typeParamScope","_nestTypeParamScope","_visitTypeAnnotation","implements","superTypeParameters","close","visitFunction","visitProperty","_node$value","InterfaceDeclaration","_createScopeVariable","extends","body","TypeAlias","right","ClassProperty","_visitClassProperty","ClassPrivateProperty","PropertyDefinition","ClassPrivateMethod","MethodDefinition","DeclareModule","_visitDeclareX","DeclareFunction","DeclareVariable","DeclareClass","OptionalMemberExpression","MemberExpression","name","currentScope","variableScope","__define","parentScope","__currentScope","scope","__nestScope","j","length","apply","arguments","Array","isArray","visitorValues","_classPrivateFieldGet","i","visitorValue","propertyType","nodeProperty","k","loopPropertyNode","l","nodeList","module","exports","analyzeScope","ast","parserOptions","_parserOptions$ecmaFe","ignoreEval","optimistic","directive","nodejsScope","sourceType","ecmaFeatures","globalReturn","impliedStrict","ecmaVersion","childVisitorKeys","getVisitorKeys","referencer"],"sources":["../src/analyze-scope.cjs"],"sourcesContent":["const {\n  Definition,\n  PatternVisitor: OriginalPatternVisitor,\n  Referencer: OriginalReferencer,\n  Scope,\n  ScopeManager,\n} = process.env.BABEL_8_BREAKING\n  ? require(\"eslint-scope\")\n  : require(\"@nicolo-ribaudo/eslint-scope-5-internals\");\nconst { getKeys: fallback } = require(\"eslint-visitor-keys\");\n\nlet visitorKeysMap;\nfunction getVisitorValues(nodeType, client) {\n  if (visitorKeysMap) return visitorKeysMap[nodeType];\n\n  const { FLOW_FLIPPED_ALIAS_KEYS, VISITOR_KEYS } = client.getTypesInfo();\n\n  const flowFlippedAliasKeys = FLOW_FLIPPED_ALIAS_KEYS.concat([\n    \"ArrayPattern\",\n    \"ClassDeclaration\",\n    \"ClassExpression\",\n    \"FunctionDeclaration\",\n    \"FunctionExpression\",\n    \"Identifier\",\n    \"ObjectPattern\",\n    \"RestElement\",\n  ]);\n\n  visitorKeysMap = Object.entries(VISITOR_KEYS).reduce((acc, [key, value]) => {\n    if (!flowFlippedAliasKeys.includes(value)) {\n      acc[key] = value;\n    }\n    return acc;\n  }, {});\n\n  return visitorKeysMap[nodeType];\n}\n\nconst propertyTypes = {\n  // loops\n  callProperties: { type: \"loop\", values: [\"value\"] },\n  indexers: { type: \"loop\", values: [\"key\", \"value\"] },\n  properties: { type: \"loop\", values: [\"argument\", \"value\"] },\n  types: { type: \"loop\" },\n  params: { type: \"loop\" },\n  // single property\n  argument: { type: \"single\" },\n  elementType: { type: \"single\" },\n  qualification: { type: \"single\" },\n  rest: { type: \"single\" },\n  returnType: { type: \"single\" },\n  // others\n  typeAnnotation: { type: \"typeAnnotation\" },\n  typeParameters: { type: \"typeParameters\" },\n  id: { type: \"id\" },\n};\n\nclass PatternVisitor extends OriginalPatternVisitor {\n  ArrayPattern(node) {\n    node.elements.forEach(this.visit, this);\n  }\n\n  ObjectPattern(node) {\n    node.properties.forEach(this.visit, this);\n  }\n}\n\nclass Referencer extends OriginalReferencer {\n  #client;\n\n  constructor(options, scopeManager, client) {\n    super(options, scopeManager);\n    this.#client = client;\n  }\n\n  // inherits.\n  visitPattern(node, options, callback) {\n    if (!node) {\n      return;\n    }\n\n    // Visit type annotations.\n    this._checkIdentifierOrVisit(node.typeAnnotation);\n    if (node.type === \"AssignmentPattern\") {\n      this._checkIdentifierOrVisit(node.left.typeAnnotation);\n    }\n\n    // Overwrite `super.visitPattern(node, options, callback)` in order to not visit `ArrayPattern#typeAnnotation` and `ObjectPattern#typeAnnotation`.\n    if (typeof options === \"function\") {\n      callback = options;\n      options = { processRightHandNodes: false };\n    }\n\n    const visitor = new PatternVisitor(this.options, node, callback);\n    visitor.visit(node);\n\n    // Process the right hand nodes recursively.\n    if (options.processRightHandNodes) {\n      visitor.rightHandNodes.forEach(this.visit, this);\n    }\n  }\n\n  // inherits.\n  visitClass(node) {\n    // Decorators.\n    this._visitArray(node.decorators);\n\n    // Flow type parameters.\n    const typeParamScope = this._nestTypeParamScope(node);\n\n    // Flow super types.\n    this._visitTypeAnnotation(node.implements);\n    this._visitTypeAnnotation(\n      node.superTypeParameters && node.superTypeParameters.params,\n    );\n\n    // Basic.\n    super.visitClass(node);\n\n    // Close the type parameter scope.\n    if (typeParamScope) {\n      this.close(node);\n    }\n  }\n\n  // inherits.\n  visitFunction(node) {\n    const typeParamScope = this._nestTypeParamScope(node);\n\n    // Flow return types.\n    this._checkIdentifierOrVisit(node.returnType);\n\n    // Basic.\n    super.visitFunction(node);\n\n    // Close the type parameter scope.\n    if (typeParamScope) {\n      this.close(node);\n    }\n  }\n\n  // inherits.\n  visitProperty(node) {\n    if (node.value?.type === \"TypeCastExpression\") {\n      this._visitTypeAnnotation(node.value);\n    }\n    this._visitArray(node.decorators);\n    super.visitProperty(node);\n  }\n\n  InterfaceDeclaration(node) {\n    this._createScopeVariable(node, node.id);\n\n    const typeParamScope = this._nestTypeParamScope(node);\n\n    // TODO: Handle mixins\n    this._visitArray(node.extends);\n    this.visit(node.body);\n\n    if (typeParamScope) {\n      this.close(node);\n    }\n  }\n\n  TypeAlias(node) {\n    this._createScopeVariable(node, node.id);\n\n    const typeParamScope = this._nestTypeParamScope(node);\n\n    this.visit(node.right);\n\n    if (typeParamScope) {\n      this.close(node);\n    }\n  }\n\n  ClassProperty(node) {\n    this._visitClassProperty(node);\n  }\n\n  ClassPrivateProperty(node) {\n    this._visitClassProperty(node);\n  }\n\n  PropertyDefinition(node) {\n    this._visitClassProperty(node);\n  }\n\n  // TODO: Update to visit type annotations when TypeScript/Flow support this syntax.\n  ClassPrivateMethod(node) {\n    super.MethodDefinition(node);\n  }\n\n  DeclareModule(node) {\n    this._visitDeclareX(node);\n  }\n\n  DeclareFunction(node) {\n    this._visitDeclareX(node);\n  }\n\n  DeclareVariable(node) {\n    this._visitDeclareX(node);\n  }\n\n  DeclareClass(node) {\n    this._visitDeclareX(node);\n  }\n\n  // visit OptionalMemberExpression as a MemberExpression